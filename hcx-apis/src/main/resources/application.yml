#kafka config
bootstrap-servers: ${bootstrap_servers:localhost:9092}

kafka:
  topic:
    payload: ${kafka_payload_topic:local.hcx.request.payload}
    coverageeligibility: ${kafka_coverageeligibility_topic:hcx.request.coverageeligibility}
    preauth: ${kafka_preauth_topic:hcx.request.preauth}
    claim: ${kafka_claim_topic:hcx.request.claim}
    payment: ${kafka_payment_topic:hcx.request.payment}
    status: ${kafka_status_topic:hcx.request.status.search}
    search: ${kafka_search_topic:hcx.request.search}
    searchresponse: ${kafka_search_response_topic:hcx.response.search}
    communication: ${kafka_communication_topic:hcx.request.communication}
    predetermination: ${kafka_predetermination_topic:hcx.request.predetermination}
    notification: ${kafka_notification_topic:hcx.request.notification}

service:
  mode: ${service_mode:gateway}

registry:
  basePath: ${registry_basePath:http://a65d6a493998b4d0e98bd690a123328b-1532825861.ap-south-1.elb.amazonaws.com:8081}
  hcxcode: ${registry_hcxcode:1-d2d56996-1b77-4abb-b9e9-0e6e7343c72e}

#postgres config
postgres:
  url: ${postgres_url:jdbc:postgresql://localhost:5432/postgres}
  user: ${postgres_user:postgres}
  password: ${postgres_password:postgres}
  tablename: ${postgres_tablename:payload}
  subscription:
    tablename: ${postgres_subscription_tablename:subscription}
    insertQuery: ${postgres_subscription_insertQuery:INSERT INTO %s as sub(id,recipientId,notificationId,status,lastUpdatedOn,mode) VALUES ('%s','%s','%s',%d,%d,'%s') ON CONFLICT ON CONSTRAINT subscription_pkey DO UPDATE SET status=%d,lastUpdatedOn=%d WHERE sub.recipientId=EXCLUDED.recipientId AND sub.notificationId=EXCLUDED.notificationId}
    subscriptionQuery: ${postgres_subscription_subscriptionQuery:SELECT notificationId,recipientId,status,mode FROM %s WHERE recipientId = '%s'}


#hcx error headers
plainrequest:
  headers:
    mandatory: ${error_mandatory_headers:x-hcx-status, x-hcx-sender_code, x-hcx-recipient_code, x-hcx-error_details, x-hcx-correlation_id, x-hcx-api_call_id, x-hcx-timestamp}
    optional: ${error_optional_headers:x-hcx-workflow_id}

#hcx headers
protocol:
  headers:
    mandatory: ${protocol_mandatory_headers:x-hcx-sender_code, x-hcx-recipient_code, x-hcx-api_call_id, x-hcx-timestamp, x-hcx-status, x-hcx-correlation_id}
    optional: ${protocol_optional_headers:x-hcx-workflow_id, x-hcx-debug_flag, x-hcx-error_details, x-hcx-debug_details}
headers:
  jose: ${jose_headers:alg, enc}

allowedEntitiesForStatusSearch: ${allowed_entities_for_status_search:coverageeligibility, preauth, claim, predetermination}

#elasticsearch config
es:
  host: ${es_host:localhost}
  port: ${es_port:9200}

#redis config
redis:
  host: ${redis_host:localhost}
  port: ${redis_port:6379}
  expires: ${redis_expires:3600}

#Audit config
audit:
  index: ${audit_index:hcx_audit}
  alias: ${audit_alias:hcx_audit}

#hcx redirect headers
redirect:
  headers:
    mandatory: ${redirect_mandatory_headers:x-hcx-sender_code, x-hcx-recipient_code, x-hcx-api_call_id, x-hcx-timestamp, x-hcx-correlation_id, x-hcx-status, x-hcx-redirect_to}
    optional: ${redirect_optional_headers:x-hcx-workflow_id}

#hcx not allowed urls
hcx:
  urls:
    notallowed: ${not_allowed_urls:http://dev-hcx.swasth.app/api,http://staging-hcx.swasth.app/api}

#Notifications related configurations
notification:
  path: ${notification_path:classpath:Notifications.json}
  headers:
    mandatory: ${notification_mandatory_headers:x-hcx-notification_id,x-hcx-sender_code, x-hcx-recipient_code, x-hcx-api_call_id, x-hcx-timestamp, x-hcx-correlation_id}
    optional: ${notification_optional_headers:x-hcx-workflow_id,x-hcx-status,x-hcx-notification_data}
